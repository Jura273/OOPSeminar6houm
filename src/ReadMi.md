Задача 1 - Iterator

� Создать класс Студент
� Создать класс УчебнаяГруппа
� Создать класс УчебнаяГруппаИтератор, заставив его реализовать интерфейс Iterator
� Реализовать его контракты (включая удаление)

Задача 2 - Iterable

� Модифицировать класс УчебнаяГруппа, заставив его реализовать интерфейс Iterable
� Реализовать метод iterator() возвращающий экземпляр созданного нами итератора

Задача 3 - Comparable

� Модифицировать класс Студент, заставив его реализовать интерфейс Comparable
� Реализовать контракт compareTo () со сравнением по какому-либо параметру (пример studentId)
� Модифицировать класс УчебнаяГруппаСервис, добавив в него метод сортировки списка студентов по id
� Модифицировать класс Контроллер, добавив в него метод сортировки списка студентов по id и вызывать в нем
созданный метод из УчебнаяГруппаСервис

Seminar4

Задача 1

� + Создать класс Юзер и перенести в него базовые поля ( ФИО )
� + Модифицировать ранее созданный класс СтудентКомпаратор
� + Переименовать в ЮзерКомпаратор
� + Типизировать его T наследующегося от типа Юзер ( T extends User )
� + Типизировать реализуемый интерфейс Компаратор T
� + Изменить метод компаре, внеся во входные данные вместо конкретных классов типизацию T
� + Внести правки места, где использовался предыдущий компаратор

Задача 2

� + Создать интерфейс ЮзерВью
� + Типизировать его T наследующегося от типа Юзер
� + Создать в нем метод sendOnConsole(List students) используя типизацию
� + Создать класс СтудентВью реализующий созданный интерфейс

Задача 3

� + Модифицировать ранее созданный класс Контроллер переименовав его в StudentController
� + Создайте новый интерфейс UserController
� + Опишите в нем метод create
� + Типизировать его T наследующегося от типа Юзер
� + В классе СтудентКонтроллер реализуйте интерфейс UserController
� + Добавить в методы контроллера вывод в консоль с помощью метода sendOnConsole


Домашняя работа к семинару №6

Взять реализованный код в рамках семинара 4
и продемонстрировать применение принципов, усвоенных на семинаре.
Нужно в проекте прокомментировать участки кода,
которые рефакторим, какой принцип применяем и почему.

Формат сдачи: ссылка на гитхаб проект

5 принципов SOLID

1 S - Single Responsibility (Принцип единственной ответственности)
Класс Student в котором применен этот принцип.
Этот класс наследник класса User отвечает за студента и изменения в нем
не затронут других пользователей User и возможных других наследников от User.

2 O - Open-Closed (Принцип открытости-закрытости)
В данном случае в класс Student виден этот принцип потому что
он не только унаследовал от класса User все его возможности,
но и дополнил (расширил) получением идентификатора (ID) и возможностью
сравнивать себя с другими студентами.

3 L - Liskov Substitution (Принцип подстановки Барбары Лисков)
В данном случае считаю что этот принцип применен в контроллере,
где StudentGroupControler наследник UserControler может заменить его
в коде с дополнительными возможностями.

4 I Interface Segregation (принципы разделения интерфейсов)
В данном случае в StudentGroup, StudentGroupIterator и
UserComporator имплементированы только необходимые
интерфейсы (специализированные) что бы потом не пришлось
ставить заглушки (в случае большого общего интерфейса).

5 D - Dependency Inversion (Принцип инверсии зависимостей)
В данном случае этот принцип применен через
StudentGroupControler имплементирующий UserControler
Он через инструменты в классах StudentGroupService,StudentGroupView
и StudentView может реализовывать различныу методы
создания, сортировки и просмотра групп студентов не затрагивая
базовых классов(Student, GroupStudent).
